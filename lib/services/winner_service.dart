import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:e_auction/views/config/config_prod.dart';

class WinnerService {
  static const String baseUrl = '${Config.apiUrllocal}/ERP-Cloudmate/modules/sales/controllers/list_quotation_type_auction_price_controller.php';
  
  // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏π‡∏•
  static Future<Map<String, dynamic>> getWinnerByAuctionId(String auctionId) async {
    try {
      print('DEBUG: Fetching winner for auction: $auctionId');
      final response = await http.get(
        Uri.parse('$baseUrl?id=$auctionId&action=get_winner'),
      );

      print('DEBUG: Winner API Response Status: ${response.statusCode}');
      print('DEBUG: Winner API Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('DEBUG: Parsed winner data: $data');
        return data;
      } else {
        throw Exception('Failed to get winner: ${response.statusCode}');
      }
    } catch (e) {
      print('DEBUG: Error getting winner: $e');
      throw Exception('Error getting winner: $e');
    }
  }

  // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏ï‡∏≤‡∏° user_id
  static Future<Map<String, dynamic>> getWinnersByUserId(String userId) async {
    try {
      print('DEBUG: Fetching winners for user: $userId');
      final response = await http.get(
        Uri.parse('$baseUrl?action=get_all_winners&winner_bidder_id=$userId'),
      );

      print('DEBUG: User Winners API Response Status: ${response.statusCode}');
      print('DEBUG: User Winners API Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('DEBUG: Parsed user winners data: $data');
        return data;
      } else {
        throw Exception('Failed to get user winners: ${response.statusCode}');
      }
    } catch (e) {
      print('DEBUG: Error getting user winners: $e');
      throw Exception('Error getting user winners: $e');
    }
  }

  // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  static Future<Map<String, dynamic>> getAllWinners() async {
    try {
      print('DEBUG: Fetching all winners');
      final response = await http.get(
        Uri.parse('$baseUrl?action=get_all_winners'),
      );

      print('DEBUG: All Winners API Response Status: ${response.statusCode}');
      print('DEBUG: All Winners API Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('DEBUG: Parsed all winners data: $data');
        return data;
      } else {
        throw Exception('Failed to get all winners: ${response.statusCode}');
      }
    } catch (e) {
      print('DEBUG: Error getting all winners: $e');
      throw Exception('Error getting all winners: $e');
    }
  }

  // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÅ‡∏≠‡∏õ
  static List<Map<String, dynamic>> convertWinnersToAppFormat(List<dynamic> winners) {
    return winners.map((winner) {
      return {
        'id': winner['quotation_more_information_id']?.toString() ?? '',
        'title': winner['short_text'] ?? winner['quotation_description'] ?? '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤',
        'finalPrice': double.tryParse(winner['winning_amount']?.toString() ?? '0') ?? 0,
        'myBid': double.tryParse(winner['winning_amount']?.toString() ?? '0') ?? 0,
        'completedDate': _formatCompletedDate(winner['winner_announced_time']),
        'image': 'assets/images/noimage.jpg', // ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å API ‡∏≠‡∏∑‡πà‡∏ô
        'status': 'won',
        'sellerName': 'CloudmateTH', // ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å API ‡∏≠‡∏∑‡πà‡∏ô
        'paymentStatus': 'pending', // ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å API ‡∏≠‡∏∑‡πà‡∏ô
        'auctionId': winner['quotation_sequence'] ?? '',
        'winnerId': winner['winner_id']?.toString() ?? '',
        'quotationId': winner['quotation_id']?.toString() ?? '',
        'winnerBidderId': winner['winner_bidder_id']?.toString() ?? '',
        'winnerBidderName': winner['winner_bidder_name'] ?? '',
        'winningBidId': winner['winning_bid_id']?.toString() ?? '',
        'auctionEndTime': winner['auction_end_time'] ?? '',
        'winnerAnnouncedTime': winner['winner_announced_time'] ?? '',
        'winnerStatus': winner['status'] ?? '',
        'winnerFirstname': winner['winner_firstname'] ?? '',
        'winnerLastname': winner['winner_lastname'] ?? '',
        'winnerPhone': winner['winner_phone'] ?? '',
        'winnerEmail': winner['winner_email'] ?? '',
        'winnerAddress': winner['winner_address'] ?? '',
        'quotationSequence': winner['quotation_sequence'] ?? '',
        'quotationDescription': winner['quotation_description'] ?? '',
        'shortText': winner['short_text'] ?? '',
        'itemNumber': winner['item_number'] ?? '',
        'quantity': winner['quantity'] ?? '',
        'countUnitId': winner['count_unit_id'] ?? '',
        'description': winner['short_text'] ?? winner['quotation_description'] ?? '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢',
        'auction_end_date': winner['auction_end_date'] ?? winner['auction_end_time'] ?? '',
      };
    }).toList();
  }

  // ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
  static String _formatCompletedDate(String? dateString) {
    if (dateString == null || dateString.isEmpty) {
      return '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà';
    }

    try {
      final date = DateTime.parse(dateString);
      final now = DateTime.now();
      final difference = now.difference(date);

      if (difference.inDays > 0) {
        return '${difference.inDays} ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß';
      } else if (difference.inHours > 0) {
        return '${difference.inHours} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß';
      } else if (difference.inMinutes > 0) {
        return '${difference.inMinutes} ‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß';
      } else {
        return '‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô';
      }
    } catch (e) {
      print('DEBUG: Error parsing date: $e');
      return '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà';
    }
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  static bool isUserWinner(Map<String, dynamic> winner, String userId) {
    final winnerBidderId = winner['winner_bidder_id']?.toString() ?? '';
    return winnerBidderId == userId;
  }

  // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  static List<Map<String, dynamic>> filterUserWinners(List<Map<String, dynamic>> allWinners, String userId) {
    return allWinners.where((winner) => isUserWinner(winner, userId)).toList();
  }

  // ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞
  static Future<Map<String, dynamic>> announceWinner(String auctionId, Map<String, String> winnerInfo) async {
    try {
      print('üöÄ ANNOUNCE: Starting winner announcement for auction: $auctionId');
      print('üöÄ ANNOUNCE: Winner info: $winnerInfo');
      
      final response = await http.post(
        Uri.parse('$baseUrl?id=$auctionId&action=announce_winner'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'winner_firstname': winnerInfo['firstname'] ?? '',
          'winner_lastname': winnerInfo['lastname'] ?? '',
          'winner_phone': winnerInfo['phone'] ?? '',
          'winner_email': winnerInfo['email'] ?? '',
          'winner_address': winnerInfo['address'] ?? '',
        }),
      );

      print('üöÄ ANNOUNCE: API Response Status: ${response.statusCode}');
      print('üöÄ ANNOUNCE: API Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('üöÄ ANNOUNCE: Success! Winner announced: ${data['message']}');
        if (data['status'] == 'success') {
          print('üéâ ANNOUNCE: Winner data: ${data['data']}');
        }
        return data;
      } else {
        print('‚ùå ANNOUNCE: Failed to announce winner: ${response.statusCode}');
        throw Exception('Failed to announce winner: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå ANNOUNCE: Error announcing winner: $e');
      throw Exception('Error announcing winner: $e');
    }
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
  static Future<void> checkAndAnnounceWinner(String auctionId, Map<String, String> winnerInfo) async {
    try {
      print('üîç TRIGGER: Checking auction $auctionId for winner announcement...');
      
      // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• auction details ‡∏à‡∏≤‡∏Å API
      final auctionResponse = await http.get(
        Uri.parse('$baseUrl?id=$auctionId&action=get_auction_details'),
      );

      if (auctionResponse.statusCode == 200) {
        final auctionData = jsonDecode(auctionResponse.body);
        print('üîç TRIGGER: Auction details response: $auctionData');
        
        if (auctionData['status'] == 'success' && auctionData['data'] != null) {
          final auction = auctionData['data'];
          final endDate = auction['auction_end_date'] ?? auction['auction_end_time'] ?? auction['end_date'] ?? auction['end_time'];
          
          print('üîç TRIGGER: Auction end date/time: $endDate');
          
          if (endDate != null && endDate.isNotEmpty) {
            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ auction ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
            if (_isAuctionEnded(endDate)) {
              print('‚úÖ TRIGGER: Auction has ended! Checking for existing winner...');
              
              // 2. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
              final winnerResponse = await http.get(
                Uri.parse('$baseUrl?id=$auctionId&action=get_winner'),
              );
              
              if (winnerResponse.statusCode == 200) {
                final winnerData = jsonDecode(winnerResponse.body);
                
                print('üîç TRIGGER: Winner check response: ${winnerData['status']}');
                
                // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞
                if (winnerData['status'] != 'success' || winnerData['data'] == null) {
                  print('üéâ TRIGGER: No winner found! Announcing winner...');
                  print('üéâ TRIGGER: Winner info: $winnerInfo');
                  
                  final result = await announceWinner(auctionId, winnerInfo);
                  print('üéâ TRIGGER: Announce result: ${result['status']} - ${result['message']}');
                } else {
                  print('‚ÑπÔ∏è TRIGGER: Winner already announced for auction: $auctionId');
                }
              } else {
                print('‚ùå TRIGGER: Failed to check winner status: ${winnerResponse.statusCode}');
              }
            } else {
              print('‚è∞ TRIGGER: Auction not ended yet: $auctionId');
            }
          } else {
            print('‚ùå TRIGGER: No end date found for auction: $auctionId');
            print('üîç TRIGGER: Trying alternative API to get auction details...');
            
            // ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡∏≠‡∏∑‡πà‡∏ô
            await _tryAlternativeAuctionDetails(auctionId, winnerInfo);
          }
        } else {
          print('‚ùå TRIGGER: Failed to get auction details: ${auctionData['message']}');
        }
      } else {
        print('‚ùå TRIGGER: Failed to get auction details: ${auctionResponse.statusCode}');
      }
    } catch (e) {
      print('‚ùå TRIGGER: Error checking and announcing winner: $e');
    }
  }

  // ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• auction ‡∏à‡∏≤‡∏Å API ‡∏≠‡∏∑‡πà‡∏ô
  static Future<void> _tryAlternativeAuctionDetails(String auctionId, Map<String, String> winnerInfo) async {
    try {
      // ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å quotation API
      final quotationResponse = await http.get(
        Uri.parse('$baseUrl?id=$auctionId&action=get_quotation_details'),
      );

      if (quotationResponse.statusCode == 200) {
        final quotationData = jsonDecode(quotationResponse.body);
        print('üîç TRIGGER: Quotation details response: $quotationData');
        
        if (quotationData['status'] == 'success' && quotationData['data'] != null) {
          final quotation = quotationData['data'];
          final endDate = quotation['auction_end_date'] ?? quotation['auction_end_time'] ?? quotation['end_date'] ?? quotation['end_time'];
          
          print('üîç TRIGGER: Quotation end date/time: $endDate');
          
          if (endDate != null && endDate.isNotEmpty) {
            if (_isAuctionEnded(endDate)) {
              print('‚úÖ TRIGGER: Auction has ended! Checking for existing winner...');
              
              // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
              final winnerResponse = await http.get(
                Uri.parse('$baseUrl?id=$auctionId&action=get_winner'),
              );
              
              if (winnerResponse.statusCode == 200) {
                final winnerData = jsonDecode(winnerResponse.body);
                
                if (winnerData['status'] != 'success' || winnerData['data'] == null) {
                  print('üéâ TRIGGER: No winner found! Announcing winner...');
                  final result = await announceWinner(auctionId, winnerInfo);
                  print('üéâ TRIGGER: Announce result: ${result['status']} - ${result['message']}');
                } else {
                  print('‚ÑπÔ∏è TRIGGER: Winner already announced for auction: $auctionId');
                }
              }
            } else {
              print('‚è∞ TRIGGER: Auction not ended yet: $auctionId');
            }
          } else {
            print('‚ùå TRIGGER: Still no end date found, skipping winner announcement');
          }
        }
      }
    } catch (e) {
      print('‚ùå TRIGGER: Error trying alternative API: $e');
    }
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ auction ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
  static bool _isAuctionEnded(String endDate, [String? endTime]) {
    try {
      String dateTimeString = endDate;
      if (endTime != null && endTime.isNotEmpty) {
        // ‡∏ñ‡πâ‡∏≤ endDate ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ß‡∏•‡∏≤ ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° endTime
        if (!endDate.contains(' ')) {
          dateTimeString = '$endDate $endTime';
        }
      }
      
      final endDateTime = DateTime.parse(dateTimeString);
      final now = DateTime.now();
      
      print('üîç TRIGGER: Current time: ${now.toString()}');
      print('üîç TRIGGER: End time: ${endDateTime.toString()}');
      print('üîç TRIGGER: Is auction ended? ${now.isAfter(endDateTime)}');
      
      return now.isAfter(endDateTime);
    } catch (e) {
      print('‚ùå TRIGGER: Error parsing date: $e');
      return false;
    }
  }

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô trigger ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
  static Future<Map<String, dynamic>> triggerAnnounceWinner(String auctionId, Map<String, String> winnerInfo) async {
    try {
      print('üöÄ TRIGGER_DIRECT: Starting direct winner announcement for auction: $auctionId');
      print('üöÄ TRIGGER_DIRECT: Winner info: $winnerInfo');
      
      final url = '$baseUrl?id=$auctionId&action=announce_winner';
      print('üöÄ TRIGGER_DIRECT: API URL: $url');
      
      // ‡πÄ‡∏û‡∏¥‡πà‡∏° debug: ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ auction ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API
      print('üîç TRIGGER_DIRECT: Checking if auction $auctionId has ended...');
      
      final response = await http.post(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'winner_firstname': winnerInfo['firstname'] ?? '',
          'winner_lastname': winnerInfo['lastname'] ?? '',
          'winner_phone': winnerInfo['phone'] ?? '',
          'winner_email': winnerInfo['email'] ?? '',
          'winner_address': winnerInfo['address'] ?? '',
        }),
      );

      print('üöÄ TRIGGER_DIRECT: API Response Status: ${response.statusCode}');
      print('üöÄ TRIGGER_DIRECT: API Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['status'] == 'success') {
          print('üéâ TRIGGER_DIRECT: Winner announced successfully!');
          print('üéâ TRIGGER_DIRECT: Winner data: ${data['data']}');
          return data;
        } else {
          print('‚ùå TRIGGER_DIRECT: Failed to announce winner: ${data['message']}');
          return data;
        }
      } else {
        print('‚ùå TRIGGER_DIRECT: HTTP Error: ${response.statusCode}');
        throw Exception('HTTP Error: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå TRIGGER_DIRECT: Error announcing winner: $e');
      throw Exception('Error announcing winner: $e');
    }
  }
} 